# Pipeline is a sequence of entry, zero or more filters, and exit,
# but yamale - and YAML - lacks a method of forcing sequence order.
# Therefore,
#   - have three required elements in the map, entry, filters, exit
#   - inclusion of filters is optional; if included, their order is
#     defined by an 'order' number, which may be overkill, since it
#     should be possible to link them via the 'out folder' types
#   - have code know about the sequence and "do the right thing",
#     mapping from n-1's types to n's, etc.
# 
pipeline:
  entry: include('entry')
  filters: list(include('filter'), required=False)
  exit: include('exit')

entry: any(include('receiver'), include('getter'))

# Probably only ever a sender, but maybe folders? TBD...
exit: any(include('sender'))
  #type: any(include('sender'), include('folder'))

receiver:
  type: regex('receiver') # regex forces specific string; str() does not
  common: include('networkAgentCommon')
  # I'd rather do this, but it is messier than I thought
  # protocol: include('protocol')
  protocol: enum('udp')
  port: include('port')

sender:
  type: regex('sender') # regex forces specific string; str() does not
  common: include('networkAgentCommon')
  # I'd rather do this, but it is messier than I thought
  # protocol: include('protocol')
  protocol: enum('udp','ssh')

getter:
  type: regex('getter') # regex forces specific string; str() does not
  common: include('networkAgentCommon')
  # I'd rather do this, but it is messier than I thought
  # protocol: include('protocol')
  protocol: enum('ssh')

networkAgentCommon:
  interfaceType: include('interfaceType')
  processInfo: include('processInfo')
  # read or write, depending whether entry or exit
  folder: include('folder')

# I'd rather do this, but it is messier than I thought
# protocol: enum('tcp', 'udp', 'ssh') # protocol varies by agent

filter:
  order:  int() # specify this manually - use this in the generation code....
  processInfo: include('processInfo')
  in: include('in') # is in really necessary? Or is n-1's out?
  out: include('out')
  err: include('err')
  canExecs: include('canExecs', required=False)

canExecs: list(include('canExec'))

canExec:
  processInfo: include('processInfo')

# is in really necessary? Or is n-1's out?
in: include('folder')

out: include('folder')

err: include('folder')

admin: include('processInfo')

auth: include('processInfo')

folder:
  path:    include('path')
  folderType:    include('folderType')
  fileTransition:    include('fileTransition', required=False)

processInfo:
  name: str()
  description: str(required=False)
  processType:       include('processType')
  startedBy:       include('startedBy')

startedBy: any(include('user'), include('system'), include('process'))

user:
  userRole: include('role')
  processTransition: include('processTransition', required=False)

system:
  systemTransition: include('initTransition')

process: any( include('receiver'), include('sender'), include('getter'), include('pipeline'), include('filter'), include('admin'), include('auth'))

# this is for later, when we use this scheme more generically
processes: list(include('process'), min=1)

# primitives/terminals to be validated
fileTransition:    str() # for now
initTransition:    str() # for now
processTransition: str() # for now

# fairly well understood primitives/terminals
port:          int()
interfaceType: str()  # the SELinux type for the interface
path:          str()  # for now; likely
role:          str()  # an SELinux role
processType:   str()  # the actual SELinux type for the process
folderType:    str()  # the actual SELinux type for the folder

